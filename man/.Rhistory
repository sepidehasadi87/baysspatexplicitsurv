#' Generate a Region
#'
#' This function generates a region of random points and plots them.
#'
#' @param n Number of points to generate.
#' @param seed Seed for random number generation.
#' @return A matrix of points.
#' @export
region <- function(n, seed) {
set.seed(seed)
A <- cbind(c(runif(n, min = 0, max = 1)), c(runif(n, min = 0, max = 1)))
plot(A)
abline(v = 0.2, col = "red")
abline(v = 0.4, col = "red")
abline(v = 0.6, col = "red")
abline(v = 0.8, col = "red")
abline(h = 0.5, col = "red")
A
}
# R/data.R
#' Simulate Data for Survival Analysis
#'
#' This function generates simulated data for survival analysis, including covariates,
#' time-to-event, and censoring times.
#'
#' @param n Number of observations
#' @param A A matrix representing the region for spatial covariates
#' @return A matrix of simulated data with covariates, time-to-event, and censoring information
#' @export
data <- function(n, A) {
library(geoR)
L <- 10 # number of partitions
p <- 6 # number of covariates + 1
ng <- 9 # number of grids in each partition
# Generate p covariates m1,..., mp
m1 <- rbinom(n, 1, 0.5)
m2 <- rbinom(n, 1, 0.5)
m3 <- rnorm(n, 0, 1)
m5 <- grf(n, grid = A, cov.model = "gaussian", cov.pars = c(sigmasq = 4, phi = 0.25, tausq = 0))
m4 <- grf(n, grid = A, cov.model = "gaussian", cov.pars = c(sigmasq = 10, phi = 0.25, tausq = 0))
one <- rep(1, n)
M <- matrix(c(one, m1, m2, m3, m4$data, m5$data), nrow = n, byrow = FALSE)
# Generate time to event
beta_real <- c(1, 1.2, 0.5, 3, 0.2, 5)
lambda <- exp(M %*% beta_real)
tt <- rexp(n = n, rate = lambda)
# Generate censoring time
cc <- runif(n, 0, 2)
# Generate y and nu
y <- rep(0, n)
nu <- rep(0, n)
for (i in 1:n) {
y[i] <- min(cc[i], tt[i])
if (tt[i] <= cc[i]) {
nu[i] <- 1
} else {
nu[i] <- 0
}
}
d <- cbind(M, y, nu, tt, cc)
return(d)
}
#' Prior Distribution for Beta Parameters
#'
#' This function computes the prior distribution for the beta parameters in a survival model.
#'
#' @param pars A vector of beta parameters
#' @return The sum of the log of the normal prior density for each beta
#' @export
prior_beta <- function(pars) {
p <- length(pars)
beta <- pars[1:p]
prior <- dnorm(beta, 0, 10)
return(sum(prior))
}
#' Calculate zA and nL Vectors
#'
#' This function calculates the `zA` vector and partition sizes (`nL`) based on input data `A`.
#'
#' @param n The number of data points.
#' @param A A matrix or data frame representing spatial data points.
#' @return A list containing the partition sizes `nL` and the normalized `zA` vector.
#' @export
zA_vector <- function(n, A) {
L <- 10
ng <- 9
ww <- partition(A) # Assuming partition is another function in your package
nL <- ww[[1]]
w <- ww[[2]]
x <- rnorm(ng, 0, 25)
zA <- rep(0, L)
nL1 <- c(0)
zAT <- 0
for (l in 1:L) {
wl <- w[((l - 1) * 9 + 1):(l * 9), ]
nL1[l + 1] <- nL1[l] + nL[l]
Al <- A[(nL1[l] + 1):nL1[l + 1], ]
for (j in 1:ng) {
dd <- 0
for (i in 1:9) {
for (m in 1:length(Al[, 1])) {
dd <- dd + dist(cbind(c(wl[i, 1], Al[m, 1]), c(wl[i, 2], Al[m, 2])))
}
}
zA[l] <- zA[l] + exp(x[j]) * exp(-dd / 2)
}
}
return(list(nL, zA / sum(zA)))
}
#' Likelihood for STSU Weibul Model
#'
#' This function computes the likelihood for the STSU Weibul model using the provided parameters.
#'
#' @param pars A vector of parameters for the Weibul model.
#' @param y A vector of observed event times.
#' @param nL A vector of partition sizes.
#' @param zA A vector of normalized partition weights.
#' @return The likelihood value for the STSU Weibul model.
#' @export
stsu_likelihood <- function(pars, y, nL, zA) {
f <- function(t1) {
mu * lambda[k] * t1^(mu - 1) * exp(-t1^mu * lambda[k])
}
lambda <- exp(M %*% pars)
lambda[lambda > exp(700)] <- exp(700) # To avoid overflow
L <- 10
LAi <- rep(0, 1)
LAl <- rep(0, 1)
int <- rep(0, 1)
k <- 0
for (l in 1:L) {
for (i in 1:nL[l]) {
k <- k + 1
int[k] <- integrate(f, 0, y[k], stop.on.error = FALSE)$value
LAi[i] <- zA[l] * (mu * lambda[k] * (y[k])^(mu - 1) * exp(-(y[k])^mu * lambda[k]))^(nu[k]) *
(1 - int[k])^(1 - nu[k])
}
LAl[l] <- sum(log(LAi))
}
LA <- sum(LAl)
return(LA + prior_beta(pars))
}
#' Partition Spatial Data
#'
#' This function divides a given spatial region into smaller partitions.
#'
#' @param A A matrix representing the region for spatial covariates
#' @return A list containing partition sizes and grid locations
#' @export
partition <- function(A) {
L <- 10
nL <- rep(0, 1)
y1 <- 0
y2 <- 0
for (i in 1:2) {
y1 <- y2
y2 <- y1 + 0.5
x1 <- 0
x2 <- 0
for (j in 1:5) {
Al <- c()
x1 <- x2
x2 <- x1 + 0.2
index <- which((A[, 1] > x1) & ((A[, 1] == x2 | A[, 1] < x2)) & (A[, 2] > y1) & ((A[, 2] == y2 | A[, 2] < y2)))
m <- j + 5 * (i - 1)
Al <- A[index, ]
nL[m] <- dim(Al)[1]
}
}
# Generating Partitions Al, nL
nL1 <- c()
nL1[1] <- 0
for (l in 1:L) {
nL1[l + 1] <- nL1[l] + nL[l]
Al <- A[(nL1[l] + 1):nL1[l + 1], ]
}
# Generating grids w
w <- c()
s1 <- matrix(c(0, .1, .2, 0, .1, .2, 0, .1, .2, 0, 0, 0, .25, .25, .25, .5, .5, .5), 9, 2)
for (i in 1:2) {
for (j in 1:5) {
s <- cbind(s1[, 1] + .2 * (j - 1), s1[, 2] + .5 * (i - 1))
w <- rbind(w, s)
}
}
return(list(nL, w))
}
